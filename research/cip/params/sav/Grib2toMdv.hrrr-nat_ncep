/**********************************************************************
 * TDRP params for Grib2toMdv
 **********************************************************************/

//======================================================================
//
// Grib2toMdv PARAMETER FILE.
//
// Grib2toMdv creates MDV from grib2 data files.  .
//
//======================================================================
 
//======================================================================
//
// PROGRAM MODES OF OPERATION.
//
//======================================================================
 
///////////// debug ///////////////////////////////////
//
// Debug option.
// 0 = No Debug info1 = Regular Debug info2 = Full Grib2 file output 
//   (see printSec params).
// Type: int
//

debug = 1;

///////////// instance ////////////////////////////////
//
// Instance.
// Process instance for registration with process mapper.
// Type: string
//

instance = "fip";

///////////// input_dir ///////////////////////////////
//
// Input directory.
// Directory which contains input GFS files. Used only if files are not 
//   specified on the command line.
// Type: string
//

input_dir = "";

///////////// input_suffix ////////////////////////////
//
// Input file suffix.
// Input file suffixes will be checked against this string. Used only if 
//   files are not specified on the command line.
// Type: string
//

input_suffix = "grb2";

///////////// max_input_data_age //////////////////////
//
// Max age (in seconds) of input data.
// Used only if files are not specified on the command line.
// Minimum val: 60
// Type: long
//

max_input_data_age = 10800;

//======================================================================
//
// PRINT SECTIONS PARAMETERS.
//
// Parameters only used with -printSec or debug > 1For each grib message 
//   prints the sections defined below.
//
//======================================================================
 
///////////// printSec_is /////////////////////////////
//
// If TRUE prints the Indicator Section.
// Only prints with -printSec or debug > 1.
// Type: boolean
//

printSec_is = FALSE;

///////////// printSec_ids ////////////////////////////
//
// If TRUE prints the Identification Section.
// Only prints with -printSec or debug > 1.
// Type: boolean
//

printSec_ids = TRUE;

///////////// printSec_lus ////////////////////////////
//
// If TRUE prints the Local Use Section (if present).
// Only prints with -printSec or debug > 1.
// Type: boolean
//

printSec_lus = FALSE;

///////////// printSec_gds ////////////////////////////
//
// If TRUE prints the Grid Definition Section.
// Only prints with -printSec or debug > 1.
// Type: boolean
//

printSec_gds = TRUE;

///////////// printSec_pds ////////////////////////////
//
// If TRUE prints the Product Definition Section.
// Only prints with -printSec or debug > 1.
// Type: boolean
//

printSec_pds = TRUE;

///////////// printSec_drs ////////////////////////////
//
// If TRUE prints the Data Representation Section.
// Only prints with -printSec or debug > 1.
// Type: boolean
//

printSec_drs = FALSE;

///////////// printSec_bms ////////////////////////////
//
// If TRUE prints the Bit-map Section.
// Only prints with -printSec or debug > 1.
// Type: boolean
//

printSec_bms = FALSE;

///////////// printSec_ds /////////////////////////////
//
// If TRUE prints the Data Section.
// Only prints with -printSec or debug > 1.
// Type: boolean
//

printSec_ds = FALSE;

//======================================================================
//
// GFS OUTPUT PARAMETERS.
//
//======================================================================
 
///////////// write_forecast //////////////////////////
//
// Write mdv files in a forecast directory structure.
// If this is true, mdv files will be written in the rap forecast 
//   directory structure.  Note that if write_non_forecast is also set to 
//   true, two mdv files will be written.
// Type: boolean
//

write_forecast = TRUE;

///////////// forecast_mdv_url ////////////////////////
//
// Url for mdv files in forecast structure.
// Type: string
//

forecast_mdv_url = "/d1/cunning/data/64-bit_mdv/fip/mdv/hrrr_nat";

///////////// write_non_forecast //////////////////////
//
// Write mdv files in a non-forecast directory structure.
// If this is true, mdv files will be written in the regular 
//   (non-forecast) rap directory structure.  Note that if write_forecast 
//   is also set to true, two mdv files will be written.  Note also that 
//   this option allows for overwriting files, since the forecast time 
//   will be used as the data time in this case.  This is a temporary 
//   option to allow for easier display of the data.
// Type: boolean
//

write_non_forecast = FALSE;

///////////// non_forecast_mdv_url ////////////////////
//
// Url for mdv files in non-forecast structure.
// Type: string
//

non_forecast_mdv_url = "";

///////////// encoding_type ///////////////////////////
//
// Set encoding type.
//
// Type: enum
// Options:
//     ENCODING_ASIS
//     ENCODING_INT8
//     ENCODING_INT16
//     ENCODING_FLOAT32
//

encoding_type = ENCODING_INT8;

///////////// compression_type ////////////////////////
//
// Set compression type.
//
// Type: enum
// Options:
//     COMPRESSION_ASIS
//     COMPRESSION_NONE
//     COMPRESSION_RLE
//     COMPRESSION_LZO
//     COMPRESSION_ZLIB
//     COMPRESSION_BZIP
//     COMPRESSION_GZIP
//

compression_type = COMPRESSION_GZIP;

///////////// non_forecast_timestamp //////////////////
//
// This parameter allows user to timestamp non-forecast mdv files based 
//   on the model's run time or the forecast time.
// The choices are TIMESTAMP_GEN_TIME and TIMESTAMP_FCAST_TIME.
//
// Type: enum
// Options:
//     TIMESTAMP_GEN_TIME
//     TIMESTAMP_FCAST_TIME
//

non_forecast_timestamp = TIMESTAMP_GEN_TIME;

///////////// data_set_info ///////////////////////////
//
// Data set info.
// This is placed in the MDV master header for documentation purposes.
// Type: string
//

data_set_info = "Converted to MDV with Grib2toMdv.";

///////////// data_set_name ///////////////////////////
//
// Data set name.
// This is placed in the MDV master header for documentation purposes.
// Type: string
//

data_set_name = "WRF-RR model output, created by NOAA/GSD.";

///////////// data_set_source /////////////////////////
//
// Data set source details.
// This is placed in the MDV master header for documentation purposes.
// Type: string
//

data_set_source = "Grib2.";

///////////// process_everything //////////////////////
//
// process all fields.
// If set, all fields will be processed, some programming may need to be 
//   addedif fields and or level types aren't defined in the out_field 
//   list. .
// Type: boolean
//

process_everything = FALSE;

//////////// output_fields ///////////////////////////
//
// List of output fields, which are descibed by the field parameter,
//   vertical level type. .
// To determine the output fields and level, use the command line
//   argument -printSummary -file [filename]
// No Mdv output is created, the user will simply be given a list of
//   fields and associated levels containedin the GRIB files.
// For a detailed description of the GRIB fields and types of vertical
//   levels see the listings  at
//   http://www.wmo.ch/web/www/WDM/Guides/Guide-binary-2.html.Select the
//   entries that represent fields of interest to the project.  Set
//   process_everything toFALSE and the output field list will be used.
// out_field_t structure definition:
//   param:string GRIB2 product ID. see link above
//   level:string GRIB2 level ID. see link above.
//   mdv_name:string MDV short field name. Used to override default
//   name. Set to empty string to keep default name
//   out_units:out_units_t simple unit conversion utility. The options
//   are:
//     NO_CHANGE            -- no change to units
//     MPS_TO_KNOTS         -- convert m/s to knots
//     M_TO_KM              -- convert meters to kilometers
//     M_TO_100FT           -- convert meters to 100's of feet,
//                             flight levels
//     PASCALS_TO_MBAR      -- convert pascals to millibars
//     KELVIN_TO_CELCIUS    -- convert degrees kelvin to to degrees
//                             celcius
//     KGPKG_TO_GPKG        -- convert kilogram per kilogram to gram
//                             per kilogram
//     PERCENT_TO_FRACTION  -- convert percentage to fraction, values
//                             between 0 and 1

//    upper_range_limit:double upper limit threshold for field.
//    lower_range_limit:double lower limit threshold for field. When
//                             both upper and lower limtes are set to
//                             zero no thresholds are applied.
//
// Type: struct
//   typedef struct {
//      string param;
//      string level;
//      string mdv_name;
//      out_units_t units;
//        Options:
//          NO_CHANGE
//          MPS_TO_KNOTS
//          M_TO_KM
//          M_TO_100FT
//          PASCALS_TO_MBAR
//          KELVIN_TO_CELCIUS
//          KGPKG_TO_GPKG
//          PERCENT_TO_FRACTION
//      double upper_range_limit;
//      double lower_range_limit;
//      encoding_type_t encoding_type;
//        Options:
//          ENCODING_ASIS
//          ENCODING_INT8
//          ENCODING_INT16
//          ENCODING_FLOAT32
//      qc_default_t qc_default_type;
//        Options:
//          BAD_VALUE
//          UNKNOWN_VALUE
//          USER_DEFINED
//      double qc_default_value;
//      int vert_level_min;
//      int vert_level_max;
//      int vert_level_dz;
//      boolean use_additional_bad_data_value;
//      double additional_bad_data_value;
//      boolean use_additional_missing_data_value;
//      double additional_missing_data_value;
//   }
//
// 1D array - variable length.
//

output_fields = {
 {
    param = "CAPE",
    level = "SPDL",
    mdv_name = "CAPE",
    units = NO_CHANGE,
    upper_range_limit = 0,
    lower_range_limit = 0,
    encoding_type = ENCODING_INT8,
    qc_default_type = BAD_VALUE,
    qc_default_value = 0,
    vert_level_min = -1,
    vert_level_max = -1,
    vert_level_dz = 1,
    use_additional_bad_data_value = FALSE,
    additional_bad_data_value = 0,
    use_additional_missing_data_value = FALSE,
    additional_missing_data_value = 0
  },
  {
    param = "CIN",
    level = "SPDL",
    mdv_name = "CIN",
    units = NO_CHANGE,
    upper_range_limit = 0,
    lower_range_limit = 0,
    encoding_type = ENCODING_INT8,
    qc_default_type = BAD_VALUE,
    qc_default_value = 0,
    vert_level_min = -1,
    vert_level_max = -1,
    vert_level_dz = 1,
    use_additional_bad_data_value = FALSE,
    additional_bad_data_value = 0,
    use_additional_missing_data_value = FALSE,
    additional_missing_data_value = 0
  },
  {    
    param = "PRES",
    level = "HYBL",
    mdv_name = "PRES",
    units = NO_CHANGE,
    upper_range_limit = 0,
    lower_range_limit = 0,
    encoding_type = ENCODING_INT8,
    qc_default_type = BAD_VALUE,
    qc_default_value = 0,
    vert_level_min = -1,
    vert_level_max = -1,
    vert_level_dz = 1,
    use_additional_bad_data_value = FALSE,
    additional_bad_data_value = 0,
    use_additional_missing_data_value = FALSE,
    additional_missing_data_value = 0
  },
  {
    param = "HGT",
    level = "HYBL",
    mdv_name = "HGT",
    units = NO_CHANGE,
    upper_range_limit = 0,
    lower_range_limit = 0,
    encoding_type = ENCODING_INT8,
    qc_default_type = BAD_VALUE,
    qc_default_value = 0,
    vert_level_min = -1,
    vert_level_max = -1,
    vert_level_dz = 1,
    use_additional_bad_data_value = FALSE,
    additional_bad_data_value = 0,
    use_additional_missing_data_value = FALSE,
    additional_missing_data_value = 0
  },
  {
    param = "TMP",
    level = "HYBL",
    mdv_name = "TMP",
    units = NO_CHANGE,
    upper_range_limit = 0,
    lower_range_limit = 0,
    encoding_type = ENCODING_INT8,
    qc_default_type = BAD_VALUE,
    qc_default_value = 0,
    vert_level_min = -1,
    vert_level_max = -1,
    vert_level_dz = 1,
    use_additional_bad_data_value = FALSE,
    additional_bad_data_value = 0,
    use_additional_missing_data_value = FALSE,
    additional_missing_data_value = 0
  },
 {
    param = "SPFH",
    level = "HYBL",
    mdv_name = "MIXR",
    units = NO_CHANGE,
    upper_range_limit = 0,
    lower_range_limit = 0,
    encoding_type = ENCODING_INT8,
    qc_default_type = BAD_VALUE,
    qc_default_value = 0,
    vert_level_min = -1,
    vert_level_max = -1,
    vert_level_dz = 1,
    use_additional_bad_data_value = FALSE,
    additional_bad_data_value = 0,
    use_additional_missing_data_value = FALSE,
    additional_missing_data_value = 0
  },
   {
    param = "VVEL",
    level = "HYBL",
    mdv_name = "VVEL",
    units = NO_CHANGE,
    upper_range_limit = 0,
    lower_range_limit = 0,
    encoding_type = ENCODING_INT8,
    qc_default_type = BAD_VALUE,
    qc_default_value = 0,
    vert_level_min = -1,
    vert_level_max = -1,
    vert_level_dz = 1,
    use_additional_bad_data_value = FALSE,
    additional_bad_data_value = 0,
    use_additional_missing_data_value = FALSE,
    additional_missing_data_value = 0
  },
  {
    param = "CLWMR",
    level = "HYBL",
    mdv_name = "CLWMR",
    units = NO_CHANGE,
    upper_range_limit = 0.1,
    lower_range_limit = 0,
    encoding_type = ENCODING_INT8,
    qc_default_type = BAD_VALUE,
    qc_default_value = 0,
    vert_level_min = -1,
    vert_level_max = -1,
    vert_level_dz = 1,
    use_additional_bad_data_value = FALSE,
    additional_bad_data_value = 0,
    use_additional_missing_data_value = FALSE,
    additional_missing_data_value = 0
  },
  {
    param = "CIMIXR",
    level = "HYBL",
    mdv_name = "ICMR",
    units = NO_CHANGE,
    upper_range_limit = 0.1,
    lower_range_limit = 0,
    encoding_type = ENCODING_INT8,
    qc_default_type = BAD_VALUE,
    qc_default_value = 0,
    vert_level_min = -1,
    vert_level_max = -1,
    vert_level_dz = 1,
    use_additional_bad_data_value = FALSE,
    additional_bad_data_value = 0,
    use_additional_missing_data_value = FALSE,
    additional_missing_data_value = 0
  },
  {
    param = "RWMR",
    level = "HYBL",
    mdv_name = "RWMR",
    units = NO_CHANGE,
    upper_range_limit = 0.1,
    lower_range_limit = 0,
    encoding_type = ENCODING_INT8,
    qc_default_type = BAD_VALUE,
    qc_default_value = 0,
    vert_level_min = -1,
    vert_level_max = -1,
    vert_level_dz = 1,
    use_additional_bad_data_value = FALSE,
    additional_bad_data_value = 0,
    use_additional_missing_data_value = FALSE,
    additional_missing_data_value = 0
  },
  {
    param = "SNMR",
    level = "HYBL",
    mdv_name = "SNMR",
    units = NO_CHANGE,
    upper_range_limit = 0.1,
    lower_range_limit = 0,
    encoding_type = ENCODING_INT8,
    qc_default_type = BAD_VALUE,
    qc_default_value = 0,
    vert_level_min = -1,
    vert_level_max = -1,
    vert_level_dz = 1,
    use_additional_bad_data_value = FALSE,
    additional_bad_data_value = 0,
    use_additional_missing_data_value = FALSE,
    additional_missing_data_value = 0
  },
  {
    param = "GRLE",
    level = "HYBL",
    mdv_name = "GRMR",
    units = NO_CHANGE,
    upper_range_limit = 0.1,
    lower_range_limit = 0,
    encoding_type = ENCODING_INT8,
    qc_default_type = BAD_VALUE,
    qc_default_value = 0,
    vert_level_min = -1,
    vert_level_max = -1,
    vert_level_dz = 1,
    use_additional_bad_data_value = FALSE,
    additional_bad_data_value = 0,
    use_additional_missing_data_value = FALSE,
    additional_missing_data_value = 0
  },
  {
    param = "APCP1Hr",
    level = "SFC",
    mdv_name = "APCP1Hr",
    units = NO_CHANGE,
    upper_range_limit = 0,
    lower_range_limit = 0,
    encoding_type = ENCODING_INT8,
    qc_default_type = BAD_VALUE,
    qc_default_value = 0,
    vert_level_min = -1,
    vert_level_max = -1,
    vert_level_dz = 1,
    use_additional_bad_data_value = FALSE,
    additional_bad_data_value = 0,
    use_additional_missing_data_value = FALSE,
    additional_missing_data_value = 0
  },
  {
       param = "HGT",
       level = "SFC",
       mdv_name = "TOPO",
       units = NO_CHANGE,
       upper_range_limit = 0,
       lower_range_limit = 0,
       encoding_type = ENCODING_INT8,
       qc_default_type = UNKNOWN_VALUE,
       qc_default_value = 0,
       vert_level_min = -1,
       vert_level_max = -1,
       vert_level_dz = 1,
       use_additional_bad_data_value = FALSE,
       additional_bad_data_value = 0,
       use_additional_missing_data_value = FALSE,
       additional_missing_data_value = 0
     }};

///////////// remap_output ////////////////////////////
//
// If TRUE remaps output.
// Type: boolean
//

remap_output = FALSE;

///////////// out_projection_info /////////////////////
//
// This is the user defined projection.
// If remap_output is true this defines the projection to remap too.The
//   choice of projections are PROJ_LATLON, PROJ_LAMBERT_CONF and
//   PROJ_FLAT. PROJ_LATLON is a latitude/longitude projection, and if it
//   is chosen the remaining parameters can be ignored. PROJ_FLAT is a
//   flat projection, and if it is chosen the parameters rotation,
//   origin_lat, origin_lon must be set. PROJ_LAMBERT_CONF is a Lambert
//   conformal projection, and if it is chosen the parameters origin_lat,
//   origin_lon, ref_lat_1 and ref_lat_2 must be set.
//
// Type: struct
//   typedef struct {
//      projection_t type;
//        Options:
//          PROJ_LATLON
//          PROJ_LAMBERT_CONF
//          PROJ_FLAT
//      double rotation;
//      double origin_lat;
//      double origin_lon;
//      double ref_lat_1;
//      double ref_lat_2;
//   }
//
//

out_projection_info = { PROJ_LAMBERT_CONF, 0, 25, -95, 25, 25 };

///////////// out_grid_info ///////////////////////////
//
// This is the user defined grid.
// if remap_output is true this defines the grid info for the remap.
//
// Type: struct
//   typedef struct {
//      int nx;
//      int ny;
//      double minx;
//      double miny;
//      double dx;
//      double dy;
//   }
//
//

out_grid_info = { 301, 225, -3332.14, -588.89, 20.318, 20.318 };


///////////// override_vlevels ////////////////////////
//
// Option to override the vlevels in the vlevel header of the specified
//   level types.
// If not empty, will replace the vlevels of variables with the
//   specified vlevel type with those specified in 'vlevel_array'.
// Normal vlevel types to replace are: 'SIGL', 'SIGMA', or 'HYBL'.
// Please note using this functionality can create incorrect levels, use
//   carefully!.
// Type: string
//

override_vlevels = "";

///////////// vlevel_array ////////////////////////////
//
// vlevel values to override what is already in the file.
// See 'override_vlevels'.
// Type: double
// 1D array - variable length.
//

vlevel_array = { 0 };

